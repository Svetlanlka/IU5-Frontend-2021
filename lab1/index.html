<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laba1</title>
    <link rel="shortcut icon" href="../images/semaphor-icon.PNG">
    <link rel="stylesheet" href="../lab1/laba1.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Akaya+Telivigala&family=Cookie&family=Knewave&family=Sacramento&display=swap" rel="stylesheet">
</head>
<body>
    <div class = "top">
        <div class = "top-element">LAB#1</div>
        <div class = "top-element">Ocheretnaya S.V.</div>
        <div class = "top-element">IU5-35B</div>
    </div>

    <div id = "about">
        <h2>Start of the first laboratory</h2> <!--Редакция 24.02.21 22.51-->
        <p>Performed by student IU5-45B,<br>Ocheretnaya Svetlana</p>
        <i>Without a beautiful design</i>
    </div>

    <div class = "intro">
        <h1>Удивительные семафоры</h1>
        
        <p>Поток должен ждать. Ждать до тех пор, пока не удастся получить эксклюзивный доступ к ресурсу или пока не появятся задачи для исполнения. Один из механизмов ожидания, при котором поток не ставится на исполнение планировщиком ядра ОС, реализуется при помощи <b>семафора</b>.</p>
        <p>Раньше я думал, что семафоры давно устарели. В 1960‑х, когда еще мало кто писал многопоточные программы, или любые другие программы, <span class = "Surname">Эдсгер Дейкстра</span> предложил идею нового механизма синхронизации — семафор. Я знал, что при помощи семафоров можно вести учет числа доступных ресурсов или создать неуклюжий аналог мьютекса, но этим, как я считал, область их применения ограничивается.</p>
        <p>Мое мнение изменилось, когда я понял, что, используя только семафоры и атомарные операции, можно создать все остальные примитивы синхронизации:
        <ul>
            <li>Легковесные мьютексы</li>
            <li>Легковесные условные переменные</li>
            <li>Легковесные read-write блокировки</li>
            <li>Примитив для решения проблемы обедающих философов</li>
            <li>Легковесный семафор</li>
        </ul>
        <p>Все эти примитивы являются легковесными в том смысле, что некоторые операции над ними исполняются полностью в userspace, и они могут (это необязательное условие) некоторое время крутиться в цикле, перед тем как запросить блокировку потока у операционной системы (примеры доступны на 
            <a href = "https://github.com/preshing/cpp11-on-multicore">GitHub</a>.) В моей библиотеке примитивов реализован класс Semaphore, который является оберткой над системными семафорами Windows, MacOS, iOS, Linux и других POSIX-совместимых ОС. Вы можете легко добавить любой из этих примитивов в свой проект.</p>
    </div>

    <div class = "semaphor-el">
        <h2>Семафор-вышибала</h2>

        <p>Представьте себе множество потоков ожидающих исполнения, выстроенных в очередь, прямо как очередь перед входом в модный ночной клуб. Семафор — это вышибала перед входом. Он позволяет пройти внутрь клуба только когда ему дают соответствующее указание.</p>
        <img src = "../images/semaphor-v1.PNG" alt = " Семафор-вышибала">
        <p>Каждый поток сам решает когда встать в эту очередь.
        Дейкстра назвал эту операцию P, что наверняка являлось отсылкой к какому-то забавно звучащему голландскому термину, 
        но в современных реализациях семафоров вы, скорее всего, обнаружите только операцию wait. 
        По сути, когда поток вызывает метод wait, он становится в очередь.</p>

        <p>Вышибала, т.е. семафор, должен уметь делать только одну операцию. Дейкстра назвал эту операцию V. 
        На сегодняшний день нет согласия в том, как именовать эту операцию. 
        Как правило, можно встретить функции post, release или signal. Я предпочитаю signal. 
        При вызове этого метода семафор «отпускает» из очереди один из ожидающих потоков. 
        (Совсем не обязательно это будет тот же поток, который вызвал wait раньше других.)</p>

        <p>А что происходит, если кто-то вызовет signal, когда в очереди нет потоков? 
        Нет проблем: когда какой-либо из потоков вызовет wait, семафор сразу же пропустит этот поток без блокировки. 
        Более того, если signal вызовут 3 раза подряд при пустой очереди, 
        то семафор разрешит следующим трем потокам, вызвавшим wait, миновать очередь без ожидания.</p>
        <img src = "../images/semaphor-v2.PNG">

        <p>Само собой разумеется, что семафор должен подсчитывать количество вызовов signal при пустой очереди. 
        Поэтому каждый семафор снабжен внутренним счетчиком, значение которого увеличивается 
        при вызове signal и уменьшается при вызове wait.</p>

        <p>Прелесть такого подхода в том, что вне зависимости от того в какой очередности вызываются wait и signal, 
        результат всегда будет одним и тем же: семафор всегда пропустит на исполнение одинаковое количество потоков, 
        и в очереди всегда останется одно и то же количество ожидающих.</p>
        <div class = "big-picture"><img src = "../images/semaphor-v3.PNG"></div>
    </div>
   
    <div class = "semaphor-el">
        <h2>Легковесный мьютекс</h2>

        <p>Я уже рассказывал, как можно реализовать собственный легковесный мьютекс в одной из предыдущих статей. В то время я не знал, что это только один из примеров применения общего паттерна, основная идея которого заключается в том, чтобы делегировать принятие решений о блокировке потоков некоторой новой сущности — <span class = "notion">box office</span>. Должен ли текущий поток ждать в очереди? Должен ли он пройти семафор без ожидания? Должны ли мы разбудить какой-то другой поток?</p>
        <img src = "../images/semaphor-l1.PNG">
        <p><i>Box office</i> ничего не знает о количестве потоков, ожидающих в очереди, как не знает он и текущее значение внутреннего счетчика семафора. Вместо этого он должен каким-то образом хранить историю собственных состояний. Если мы говорим о реализации легковесного мьютекса, то для хранения истории достаточно одного счетчика с атомарными операциями инкремента и декремента. Я назвал этот счетчик <i>m_contention</i>, т.к. он хранит информацию о том, сколько потоков одновременно желают захватить мьютекс.</p>
        <div id = "code">
            class LightweightMutex
            {
            private:
                std::atomic<int> m_contention;         // The "box office"
                Semaphore m_semaphore;                 // The "bouncer"
        </div>
        <p>Когда поток хочет захватить мьютекс, он обращается к box office, который в свою очередь увеличивает значение <i>m_contention.</i></p>
        <div id = "code">
        public:
            void lock()
            {
                if (m_contention.fetch_add(1, std::memory_order_acquire) > 0)  // Visit the box office
                {
                    m_semaphore.wait();     // Enter the wait queue
                }
            }
        </div>
        
        <p>Если значение счетчика равно нулю, значит мьютекс находится в неотмеченном состоянии. В этом случае текущий поток автоматически становится владельцем мьютекса, минует семафор без ожидания и продолжает работу в секции кода, защищенной мьютексом.</p>
        <p>Если же мьютекс уже захвачен другим потоком, то значение счетчика будет больше нуля и текущий поток должен ожидать своей очереди для входа в критическую секцию.</p>
        <img src = "../images/semaphor-l2.PNG">
        <p>Когда поток освобождает мьютекс, <i>box office</i> уменьшает значение внутреннего счетчика на единицу:</p>
        <div id = "code">
            void unlock()
            {
                if (m_contention.fetch_sub(1, std::memory_order_release) > 1)  // Visit the box office
                {
                    m_semaphore.signal();   // Release a waiting thread from the queue
                }
            }
        </div>
        <p>Если значение счетчика до декремента было меньше 1, значит в очереди нет ожидающих потоков и значение m_contention просто остается равным 0.</p>
        <p>Если же значение счетчика было больше 1, значит другой поток или несколько потоков пытались захватить мьютекс, и, следовательно, ожидают своей очереди войти в критическую секцию. В этом случае мы вызываем signal, чтобы семафор разбудил один из потоков и дал ему возможность захватить мьютекс.</p>
        <img src = "../images/semaphor-l3.PNG">
        <p>Каждое обращение к box office — это атомарная операция. Таким образом, даже если несколько потоков будут вызывать lock и unlock параллельно, они всегда будут обращаться к box office последовательно. Более того, поведение мьютекса полностью определяется внутренним состоянием box office. После обращения к box office, потоки могут вызывать методы семафора в любом порядке, и это никоим образом не нарушит согласованности исполнения. (В худшем случае потоки поборются за место в очереди семафора.)</p>
        <p>Данный примитив можно назвать <i>«легковесным»</i>, так как он позволяет потоку захватить мьютекс без обращения к семафору, т.е. без совершения системного вызова. Я опубликовал код мьютекса на GitHub под названием <span class = "notion">NonRecursiveBenaphore</span>, там же есть и рекурсивная версия легковесного мьютекса. Тем не менее, нет предпосылок использовать этим примитивы на практике, т.к. большинство известных реализаций мьютексов и так являются легковесными. Тем не менее, этот код служит необходимой иллюстрацией подхода, который используется для всех прочих примитивов, описанных в данной статье.</p>
    </div>
    <div class = "semaphor-el">
        <h2>Легковесный семафор</h2>

        <p>Да, все верно: при помощи паттерна box office и семафора мы можем реализовать… другой семафор.</p>
        <p>Зачем нам это делать? Потому что тогда мы получим <span class = "notion">LightweightSemaphore</span>. У такого семафора очень дешевая операция signal, когда в очереди нет ожидающих потоков. К тому же она не зависит от реализации семафора, предоставляемого ОС. При вызове signal, box office увеличивает значение собственного внутреннего счетчика, не обращаясь к нижележащему семафору.</p>
        
        <img src = "../images/semaphor-ls1.PNG">

        <p>Кроме того, можно заставить поток некоторое время ожидать в цикле, и лишь потом блокировать его. Этот трюк позволяет снизить накладные расходы связанные с системным вызовом, если время ожидание меньше какого-то наперед заданного значения.</p>
        <p>В GitHub репозитории все примитивы реализованы на основе <span class = "notion">LightweightSemaphore</span>. Этот класс реализован на основе Semaphore, который в свою очередь реализован на базе семафоров, предоставляемых конкретной ОС.</p>
        <img src = "../images/semaphor-ls2.PNG">
        
        <p>Я прогнал несколько тестов для сравнения скорости работы представленных примитивов при использвании <span class = "notion"></span>LightweightSemaphore</span> и Semaphore на моем PC под управлением Windows. Соответствующие результаты приведены в таблице:</p>
        <table>
            <tr>
                <th></th>
                <th>LightweightSemaphore</th>
                <th>Semaphore</th>
            </tr>
            <tr>
                <td>testBenaphore</td>
                <td>375 мс</td>
                <td>5503 мс</td>
            </tr>
            <tr>
                <td>testRecursiveBenaphore</td>
                <td>393 мс</td>
                <td>404 мс</td>
            </tr>
            <tr>
                <td>testAutoResetEvent</td>
                <td>593 мс</td>
                <td>4665 мс</td>
            </tr>
            <tr>
                <td>testRWLock</td>
                <td>598 мс</td>
                <td>7126 мс</td>
            </tr> 
            <tr>
                <td>testDiningPhilosophers</td>
                <td>309 мс</td>
                <td>580 мс</td>
            </tr>
        </table>	
        <p>Как вы можете видеть, время работы отличается иногда на порядок. Надо сказать, я отдаю себе отчет в том, что далеко не в каждом окружении будут такие же или похожие результаты. В текущей реализации поток ждет в течение 10 000 итераций цикла перед тем как заблокироваться на семафоре. Я бегло рассматривал возможность использования адаптивного алгоритма, но наилучший способ показался мне неочевидным. Так что я открыт для предложений.</p>
    </div>

    <form action="reg.php">
          <h1>Registration form</h1>
          <label for="email"><b>Email</b></label>
          <input type="text" placeholder="Введите почту:" name="email" required>
      
          <label for="psw"><b>Password</b></label>
          <input type="password" placeholder="Введите пароль:" name="password" required>

          <label for="select-group"><b>Выберите группу</b></label>
          <select name="select-group">
            <option value="group1">ИУ5-41Б</option>
            <option value="group2" selected>ИУ5-42Б</option>
            <option value="group3">ИУ5-43Б</option>
            <option value="group4">ИУ5-44Б</option>
            <option value="group5">ИУ5-45Б</option>
          </select>
         
          <button type="submit" class="button-reg">Отправить данные</button>
        </div>
    </form>
    <br>

    <div class = "cell">
        <div class = "cell-el"><a href = "../">Вернуться</a></div>
        <div class = "cell-el"><a href ="https://vk.com/svetlanlka" alt="Светлана Очеретная">Мой ВК</a>подписывайтесь)</div>
    </div>
</body>

</html>